# Some Dissembly Required

## x) Read/watch/listen and summarize

* Hammond 2022: [Ghidra for Reverse Engineering (PicoCTF 2022 #42 'bbbloat')](https://www.youtube.com/watch?v=oTD_ki86c9I). In this video, John Hammond demonstrates how to solve a "reverse engineering" challenge from PicoCTF 2022. Here is a brief summary of the steps he takes:
    * He starts by running the program, which asks for a "favorite number." Since he doesn't know the answer, the program exits.
    * He tries several *basic tools* first like `ltrace`, `strace`, `gdb`, etc. to seek some *low hanging fruits*, but they don't provide the answer.
    * He then opens the file in Ghidra&mdash;a popular reverse engineering tool. By searching for the text "favorite number" in *defined strings*, he traces the exact place in the code where the check happens.
    * Inside the code, he discovers the hexadecimal value `0x86187` (i.e. `549255` in decimal) which is used to reveal the *flag* of the challenge&mdash;`picoCTF{...}`.

* Optional: € Eagle and Nancy 2020: [The Ghidra Book: 2. Reversing And Disassembly Tools](https://learning.oreilly.com/library/view/the-ghidra-book/9781098125684/xhtml/ch02.xhtml#ch02lev29). Look, I’d love to dive into *The Ghidra Book* and give you the summary of Chapter 2, but there’s a slight technical difficulty&mdash;my wallet is currently screaming *"Not enough minerals!"* I tried typing *"show me the money"* with my keyboard about fifty times, but apparently, it does not work. No 10,000 gas, no 10,000 minerals, and definitely no "free" access to O'Reilly's library for me either. Just `F10`, `E`, `Q` then.

## a) Install Ghidra

It's just easy peasy! All I have to do is just to follow the installation guides, here and there.

* Install [SDKMAN!](https://sdkman.io/)
```bash
$ curl -s "https://get.sdkman.io" | bash
``` 
* Install [JDK 21 64-bit](https://adoptium.net/temurin/releases)
```bash
$ sdk install java 21.0.9-ms
```
* Download the [release file](https://github.com/NationalSecurityAgency/ghidra/releases)
```bash
$ wget https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_12.0.2_build/ghidra_12.0.2_PUBLIC_20260129.zip
```
* Extract the Ghidra release file.
```bash
$ unzip ghidra_12.0.2_PUBLIC_20260129.zip
```

Because I'm using an ARM-based system, I have to perform some addition steps&mdash;but they are still *pieces of cake!*

* Install [Gradle](https://gradle.org/)
```bash
$ sdk install gradle
```
* Build Ghidra's native components
```bash
$ cd ghidra_12.0.2_PUBLIC/support/gradle/
$ gradle buildNatives
```

Let's reverse engineer!

## b) packd

> ***TL;DR;*** `piilos-AnAnAs` is the solution. By using Ghidra's **Analyze**, **Dissamble** and **Defined Strings** features, we can easily trace the entrypoint and the whole logic of the program.

Honestly, I struggled from the start. I couldn't apply anything I learned from the Ghidra workshop. No `strcmp`, no `__libc_` prefix, etc. Nothing! Even though I found a string `What's the password?` in the Defined strings window, but double clicking on it didn't lead me anywhere. Why? Is it that difficult? I remember Tero said to us that this is just a beginner level. Really?

Then, I read the tips again, and&mdash;wait! I realized this is the zip file used in the h3 homework. Was't it `packd` that was *packed*? Oh man, how could I miss that part? I scrambled back to my laptop, whipped open the terminal, and&mdash;with the extreme caution of a man who just realized he’s been trying to decompile a packed file for an hour&mdash;I retried every single step.

* Unpack the binary
```bash
$ upx -d packd
```
* Use Ghidra to open the unpacked version

![Unpacked packd analyzed with Ghidra](screenshots/b/packd.png)

*"Battlecruiser operational!"* `piilos-AnAnAs`

## c) Patch the passtr

> ***TL;DR;*** `passtr_hacked` is the solution. By using Ghidra’s **Patch Instruction** feature, we can edit a program's logic even without the source code.

Once I achieve a victory, I don't want to stop! You feel the same, right? Next opponent, please!

This time, the challenge is a bit trickier: I have to modify the code... *without* the code. Interesting! Let’s see how far I can go. 

As usual, I open Ghidra and summon the enemy!

![Analyze passtr with Ghidra](screenshots/c/01.png)

A-ha! Lucky me! The logic is straightforward: ask for input, check it against a hard-coded value, and print whether it's right or wrong. 

**Mission Objective:** Modify the binary so it accepts all passwords except the correct one.

Isn't it just a matter of replacing `==` with `!=`? Easy peasy. I head back to Ghidra, place the cursor on the `==` operator, hit Delete, and&hellip; nothing. It's read-only. How do I do this in Ghidra? This tool is quite new to me, but I'll master it someday, I promise!

After some Googling, I discover that while I can't edit the decompiled C code directly, I can patch the instructions in assembly. Phew! Luckily, I’ve spent some time playing with assembly&mdash;a language definitely not meant for humans. 

In the mean time, I also find out that Ghidra has a great feature that highlights the corresponding assembly code when you select a line of C. 

![A super useful feature of Ghidra](screenshots/c/02.png)

Now, it's time to call for help from my ally&mdash;AI! I ask it: *"What do `TEST EAX, EAX` and `JNZ LAB_...` do?"*

Here is its answer.

> *In plain English: This sequence says: "Take a look at what's in EAX. If it's anything other than zero, go over to the section labeled LAB_.... Otherwise, just keep going."*&mdash;I just quote some of its response here for abbreviation.

Exactly what I thought! The *LAB_...* section handles the *"Sorry, no bonus"* message. Now, if I change `JNZ` (Jump if Not Zero) to `JZ` (Jump if Zero), I’ll invert the logic. The "if" becomes the "else". I must admit that I'm a genius!

I head back to Ghidra again, right click the `JNZ` instruction, select **Patch Instruction (Ctrl+Shift+G)**, change it to `JZ`, hit Enter, and&hellip;

![Using Patch Instruction feature of Ghidra](screenshots/c/03.png)

&hellip;it reverts right back to `JNZ`. Nothing else happens. Again! What's wrong with you, Ghidra? Don't test my patience, please. I'm not giving up when I am this close to the finish line. 

I bury myself in forums, searching for a way to slay this final boss. Just when I think it is a "Game Over", I find a lifeline.

[Patching binaries with Ghidra](https://www.youtube.com/watch?v=8U6JOQnOOkg) &ndash; SoonerBourne

Following the video, I re-import the original binary into Ghidra (using **Raw Binary** option this time), analyze it, trace the jump instruction, patch it, save it, and export it. It works. I name it `passtr_hacked`.

![Successfully patch the binary](screenshots/c/04.png)

Now it's time to eliminate the final boss and end my campaign.

```bash
$ ./passtr
What's the password?
test
Sorry, no bonus.
```

```bash
$ ./passtr_hacked 
What's the password?
test
Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}
```

GGWP! Another victory for me!

## d) Prepare for crackme challenges

Next, let's meet our new opponents! 

```bash
$ git clone https://github.com/NoraCodes/crackmes
$ cd crackmes/
$ gcc -Wall -o crackme01 crackme01.c
$ gcc -Wall -o crackme01e crackme01e.c
$ gcc -Wall -o crackme02 crackme02.c
$ gcc -Wall -o crackme02e crackme02e.c
```

**Important!** The pre-built binary *crackmes* monsters I built with Ubuntu ARM64. Remember to get well prepared before facing them in battles.

## e) crackme01

Another easy win!

* Import to Ghidra

![Import crackme01 binary](screenshots/e/01.png)

* Analyze the source code

![Analyze to understand source code](screenshots/e/02.png)

* Patch the source code

![Identify the point to hack](screenshots/e/03.png)
![Patch instruction](screenshots/e/04.png)

This is the enemy with 100% HP.

```bash
$ ./crackme01 || echo $?
Need exactly one argument.
255
$ ./crackme01 test || echo $?
No, test is not correct.
1
$ ./crackme01 password1 || echo $?
Yes, password1 is correct!
```

Enemy down!

```bash
$ ./crackme01_hacked || echo $?
Need exactly one argument.
255
$ ./crackme01_hacked test || echo $?
Yes, test is correct!
```

## e*) crackme01e

Not even a match!

```bash
$ ./crackme01e || echo $?
Need exactly one argument.
255
$ ./crackme01e test || echo $?
No, test is not correct.
1
$ ./crackme01e 'slm!paas.k' || echo $?
Yes, slm!paas.k is correct!
```

```bash
$ ./crackme01e_hacked || echo $?
Need exactly one argument.
255
$ ./crackme01e_hacked test || echo $?
Yes, test is correct!
$ ./crackme01e_hacked 'slm!paas.k' || echo $?
No, slm!paas.k is not correct.
1
```

## f) crackme02

> ***TL;DR;*** `crackme02_hacked` is the solution. You can use `crackme02_helper` to  *obfuscate* any given input to find the *hidden password*.

Next opponent is quite challenging. Let's follow me!

![Import crackme02 to Ghidra](screenshots/f/01.png)

The logic is different but still straightforward and easy to understand: compare the password and the user input; if the password does not match, show the error message and abort; otherwise, accept it. The overall behavior is similar, but the comparison is rewritten to incorporate the obfuscation logic of hiding the hidden password from the hard-coded value. We cannot simply enter the string we find in the assembly and the door will open. No!

![Analyze crackme02 binary](screenshots/f/02.png)

Well, I said we needed to get well-prepared ealier. Remember? I have already made a tool myself. It helps me reveal the hidden password in this challenge.
* Source: [crackme02_helper.c](challenges/crackmes/crackme02_helper.c)
* Binary (Linux ARM64): [crackme02_helper](challenges/crackmes/crackme02_helper)

It definitely requires a bit of concrete skills&mdash;C programming language. It's not that hard. After a couple of hours, you will get the same feeling. Trust me!

But that's not the hardest part in my campaign. Mission objective: ***Bypass the password protection but still keep other functionalities work.*** For this current logic, the best way is that, we patch the binary to swap the two codeblocks: one says password is correct, and one says no. 

One thing I need to remind you when patching: we can only modify the assembly when we use **Patch Instruction** feature. To do that, we have to understand what and how it works. We need to find exactly which sections of the assembly, how many lines to swap, whether the swap affects the memory locations of variables, constants, etc. 

Luckily, I discover another important feature in Ghidra, which proves its effectiveness for these kinds of activities&mdash;Comments. By using this feature, now I can read the logic flow directly in the assembly&mdash;like I said, not meant for human.

![Use Comments feature to mark steps of the logic](screenshots/f/03.png)

After a few hours reading the assembly&mdash;you don't hear me wrong, I read it; of course, with the support of my right-handed AI friend&mdash;I find the two exact codeblocks. Then, I just need to patch the binary.

![Brainwash the enemy](screenshots/f/04.png)

From now on, everything is simple.

```bash
$ ./crackme02_helper password1
o`rrvnqc0
```

```bash
$ ./crackme02 || echo $?      
Need exactly one argument.
255
$ ./crackme02 test || echo $?
No, test is not correct.
1
$ ./crackme02 'o`rrvnqc0' || echo $?
Yes, o`rrvnqc0 is correct!
```

```bash
$ ./crackme02_hacked || echo $?
Need exactly one argument.
255
$ ./crackme02_hacked test || echo $?
Yes, test is correct!
$ ./crackme02_hacked 'o`rrvnqc0' || echo $?
No, o`rrvnqc0 is not correct.
1
```

Another victory!
